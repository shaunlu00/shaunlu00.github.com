---
layout: post
title: "Hibernate Tutorial(5) - Interceptors and Auditing"
subtitle: 'Hibernate Interceptors and Auditing'
author: "Shaun"
header-style: text
tags: ["Hibernate"]
---

Hibernate is one of the most popular ORM solutions. As a JPA provider, it sits between database and DAL(Data Access
Layer), taking care of mappings from POJO to tables.
This serials will illustrate how to use Hibernate in detailed examples:

[-> (1) Hibernate Tutorial(1) - Basic Concepts]({{ site.baseurl }}/2019/11/01/Hibernate(1)/)  
[-> (2) Hibernate Tutorial(2) - Domain Model]({{ site.baseurl }}/2019/10/12/Hibernate(2)/)  
[-> (3) Hibernate Tutorial(3) - Query]({{ site.baseurl }}/2020/01/22/Hibernate(3)/)  
[-> (4) Hibernate Tutorial(4) - Transaction and Locking]({{ site.baseurl }}/2020/01/31/Hibernate(4)/)  
[-> (5) Hibernate Tutorial(5) - Interceptors and Auditing]({{ site.baseurl }}/2020/02/02/Hibernate(5)/)  
    

You can find all examples at [https://github.com/shaunlu00/hibernate-tutorial](https://github.com/shaunlu00/java-tutorial-jackson)

---
## 1 Interceptors
It is useful for the application to react to certain events.
### 1\.1 Hibernate Interceptors
Developers can define callbacks before an entity is saved, updated deleted or loaded.
```java
@Slf4j
public class LoggingInterceptor extends EmptyInterceptor {
    @Override
    public boolean onSave(
            Object entity,
            Serializable id,
            Object[] state,
            String[] propertyNames,
            Type[] types) {

        log.info("-------------Entity {}-{} saved with state{}-------------",
                entity.getClass().getSimpleName(),id, state);
        return super.onSave(entity, id, state, propertyNames, types);
    }
}
```
### 1\.2 JPA Callbacks
JPA provides two approaches for specifying callback handling:
- annotate methods on the entity: `@PrePersist`, `@PreRemove`, `@PostPersist`, `@PostRemove`, `@PreUpdate`, `@PostUpdate`, `@PostLoad`
- use a entity listener class  

These two approaches can be mixed
```java
@Entity
@EntityListeners(Person.JPAListener.class)
public class Person {

    @Id
    @GeneratedValue
    private Long id;

    private String name;

    private LocalDateTime createTime;

    @PreUpdate
    @PrePersist
    public void setCreateTime() {
        createTime = LocalDateTime.of(2020,2,2,10,0,0);
    }

    public static class JPAListener {
        @PostLoad
        public void postLoad(Person p) {
            p.setName("shaun");
        }
    }
}

public class EventTest {
    @Test
    public void testInterceptor() {
        EntityManagerFactory emf = HibernateHelper.getEMF();
        SessionFactory sessionFactory = emf.unwrap(SessionFactory.class);
        Session session = sessionFactory.withOptions().interceptor(new LoggingInterceptor()).openSession();
        session.getTransaction().begin();
        Robot robot = new Robot();
        robot.setName("robot");
        session.save(robot);
        session.getTransaction().commit();
    }
    @Test
    public void testJPACallbacks() {
        HibernateHelper.doInTransaction(entityManager -> {
            Person person = new Person();
            entityManager.persist(person);
        });
        HibernateHelper.doQuery(entityManager -> {
            Person person = entityManager.createQuery("select p from Person p", Person.class).getSingleResult();
            assertEquals("shaun", person.getName());
            assertTrue(LocalDateTime.of(2020,2,2,10,0,0).isEqual(person.getCreateTime()));
        });
    }
}
```

---
## 2 Auditing
To audit changes that are performed on an entity, you only need to include `hibernate-envers` dependency 
and use `@Audited` annotation.  
```java
@Entity
@Audited
public class UserEmail {
    @Id
    @GeneratedValue
    private Long id;

    private String userId;

    private String email;
}
```
Hibernate creates two tables: `REVINFO` and `USEREMAIL_AUD`
```sql
create table REVINFO (
    REV integer generated by default as identity,
    REVTSTMP bigint,
    primary key (REV)
)

create table OPERATIONLOG_AUD (
    id bigint not null,
    REV integer not null,
    REVTYPE tinyint,
    userId varchar(255),
    operation varchar(255),
    primary key (id, REV)   
)
```
The table `USEREMAIL_AUD` records every change with revision number and type(REVTYPE):
- 0 ADD
- 1 MOD
- 2 DEL  

The table `REVINFO` table stores revision id and create time
### 2\.1 Audit Strategy
There are two audit strategies:
- default: persist audit data with a revision numberï¼Œ and records in audit table will never be updated after being inserted
- each audit record refers a revision and the entity's end revision  

#### 2\.1\.1 Only persist revision number with audit record
For example with default strategy, we do some operations on this table
```
1 save an entity (111, John, john@gmail.com)
2 update this entity (111, John, john@outlook.com)
3 delete this entity
4 save another entity (111, Peter, peter@gmail.com)
```
Then we get audit results as following: 

| id | REV | REVTYPE | userId | email |
| --- | ----------- |
| 1 | 1 | 0 | John | john@gmail.com |
| 1 | 2 | 1 | John | john@outlook.com |
| 1 | 3 | 3 | null | null |
| 2 | 4 | 0 | Peter | peter@gmail.com |

To get the last revision for this entity, we need to use subqueries: 
```sql
select id, rev, revtype, userid, email
from USEREMAIL_AUD t
where t.rev = (
   select max(rev) as from 
   USEREMAIL_AUD t1 
   where t1.id = t.id
)
```
The subquery is slow and difficult to index, so let's see an alternative way
#### 2\.1\.2 Persist the end revision number for each audit record
To change the default strategy, you need to set `org.hibernate.envers.audit_strategy=org.hibernate.envers.strategy.ValidityAuditStrategy`. 
When rerunning the previous example, we get the following results:  

| id | REV | REVTYPE | REVEND | userId | email |
| --- | --- | --- | --- | --- | --- |
| 1 | 1 | 0 | 3 | John | john@gmail.com |
| 1 | 2 | 1 | 3 | John | john@outlook.com |
| 1 | 3 | 3 | 3 | null | null |
| 2 | 4 | 0 | null | Peter | peter@gmail.com |

To select the last revision for this entity, the query sql is:
```sql
select id, rev, revtype, userid, email
from USEREMAIL_AUD t
where t.revend is null or t.rev = t.revend
```
This query is a lot faster but the downside is that each update takes more time 
as other rows(with the same id) will be updated.
### 2\.3 Queries
Now you can use `AuditReader` to query all revisions for an given entity:
```java
AuditReader auditReader =AuditReaderFactory.get(entityManager);
List<Number> revisions = auditReader.getRevisions(UserEmail.class, 1L);
UserEmail userEmail = (UserEmail) auditReader.createQuery().forEntitiesAtRevision(UserEmail.class, revisions.get(0)).getSingleResult();
```